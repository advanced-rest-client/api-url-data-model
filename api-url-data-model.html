<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-if.html">
<link rel="import" href="../raml-aware/raml-aware.html">
<link rel="import" href="../api-view-model-transformer/api-view-model-transformer.html">
<dom-module id="api-url-data-model">
  <template>
    <style>:host {display: none;}</style>
    <template is="dom-if" if="[[aware]]">
      <raml-aware raml="{{webApi}}" scope="[[aware]]"></raml-aware>
    </template>
    <api-view-model-transformer id="transformer"></api-view-model-transformer>
  </template>
  <script>
  (function() {
    const VOC_DOC = 'http://raml.org/vocabularies/document#';
    const VOC_HTTP = 'http://raml.org/vocabularies/http#';
    const HYD_CORE = 'http://www.w3.org/ns/hydra/core#';

    const HTTP_PARAM = VOC_HTTP + 'parameter';
    /**
     * `api-url-data-model`
     * An element to generate view model for api-url-editor and api-url-params-editor elements from AMF model
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class ApiUrlDataModel extends Polymer.Element {
      static get is() { return 'api-url-data-model'; }
      static get properties() {
        return {
          /**
           * A web API model generated by the AMF.
           * This property is required to compyte parameters properly.
           */
          webApi: {
            type: String,
            observer: '_webApiChanged'
          },
          /**
           * Name of the scope to use with `raml-aware`.
           * If this element is used with other aware elements, it updates
           * `webApi` when aware value change.
           */
          aware: String,
          /**
           * The `@id` property of selected endpoint and method to compute
           * data models for.
           */
          selected: {
            type: String,
            observer: '_selectedChanged'
          },
          /**
           * Computed view model for API uri parameters.
           */
          apiParameters: {
            type: Array,
            readOnly: true,
            notify: true
          },
          /**
           * Computed value of API base URI.
           */
          apiBaseUri: {
            type: String,
            readOnly: true,
            notify: true
          },
          /**
           * Generated view model for query parameters.
           */
          queryModel: {
            type: Array,
            readOnly: true,
            notify: true
          },
          /**
           * Generated view model for path parameters
           *
           * @type {Object}
           */
          pathModel: {
            type: Array,
            readOnly: true,
            notify: true
          },
          /**
           * Computed value of full endpoint URI when selection has been made.
           */
          endpointUri: {
            type: String,
            notify: true,
            readOnly: true
          },
          /**
           * Selected emndponit relative path.
           */
          endpointPath: {
            type: String,
            notify: true,
            readOnly: true
          }
        };
      }
      /**
       * Clears computed base values of the API.
       */
      _resetBaseValues() {
        this._setApiBaseUri(undefined);
        this._setApiParameters(undefined);
      }
      /**
       * Clears variables related to selected object.
       */
      _resetObjectValues() {
        this._setQueryModel(undefined);
        this._setPathModel(undefined);
      }
      /**
       * Computes basic properties when model change.
       * @param {Object} model The document model
       */
      _webApiChanged(model) {
        this._resetBaseValues();
        if (model instanceof Array) {
          model = model[0];
        }
        if (!this._modelHasType(model, VOC_DOC + 'Document')) {
          return;
        }
        const encodes = model[VOC_DOC + 'encodes'];
        model = encodes.find((item) => this._modelHasType(item, 'http://schema.org/WebAPI'));
        if (!model) {
          return;
        }
        this._computeApiUriParams(model);
        this._computeApiBaseUri(model);
      }
      /**
       * Computes `apiBaseUri` property when `amfModel` change.
       *
       * @param {Object} model The `http://schema.org/WebAPI` model
       */
      _computeApiBaseUri(model) {
        let scheme = this._getAmfValue(model[VOC_HTTP + 'scheme']);
        const host = this._getAmfValue(model[VOC_HTTP + 'host']);
        const basePath = this._getAmfValue(model[VOC_HTTP + 'basePath']);
        if (host && !scheme) {
          scheme = 'http';
        }
        if (!scheme || !host) {
          return;
        }
        let result = scheme + '://' + host;
        if (basePath) {
          result += basePath;
        }
        const len = result.length - 1;
        if (result[len] === '/') {
          result = result.substr(0, len);
        }
        this._setApiBaseUri(result);
      }
      /**
       * Computes uri paramerters lsit for API base
       * @param {Object} model The `http://schema.org/WebAPI` model
       */
      _computeApiUriParams(model) {
        let params = model[HTTP_PARAM];
        if (!params) {
          return;
        }
        return this.$.transformer
        .computeViewModel(params)
        .then((data) => this._setApiParameters(data));
      }

      /**
       * Checks if a model has a type.
       * @param {Object} model Model to test
       * @param {String} type Type name
       * @return {Boolean} True if model has a type.
       */
      _modelHasType(model, type) {
        const types = model['@type'] || [];
        const index = types.findIndex((item) => item === type);
        return index !== -1;
      }

      /**
       * @param {Object} model Amf model
       * @return {String|undefined} Value for the model.
       */
      _getAmfValue(model) {
        if (!model || !(model instanceof Array)) {
          return;
        }
        model = model[0];
        return model['@value'];
      }
      /**
       * Handler for the `selected` property change.
       * Computes model for URI and query parameters from selected endpoint.
       *
       * @param {String} id The `@id` property of selected object.
       */
      _selectedChanged(id) {
        this._resetObjectValues();
        if (!id) {
          return;
        }
        const api = this.webApi;
        if (!api) {
          return;
        }
        const endpointId = this.computeEndpointId(id);
        const endpoint = this.findEndpoint(endpointId, api);
        if (!endpoint) {
          return;
        }
        const endpointPath = this._getAmfValue(endpoint[VOC_HTTP + 'path']);
        const endpointUri = this.computeEndpointUri(endpointPath);
        this._setEndpointPath(endpointPath);
        this._setEndpointUri(endpointUri);
        this._setupPathViewModel(endpoint[HTTP_PARAM]);
        if (endpointId === id) {
          return;
        }
        const method = this.findMethod(id, endpoint[HYD_CORE + 'supportedOperation']);
        if(!method) {
          console.warn('Method not found in endpoint definition.', id);
          return;
        }
        this._setupQueryViewModel(method);
      }
      /**
       * Computes endpoint `@id` for given `id`.
       * On a base level it subrtacts the last part after `/` which
       * is a delimiter between endpoint identifier and method name.
       *
       * @param {String} id Object ID. Can be operation's or endpoint's ID.
       * @return {String} Endpoint id. It may return the same value if passed
       * id is endpoint ID.
       */
      computeEndpointId(id) {
        if (!id) {
          throw new Error('Argument "id" is required.');
        }
        const parts = id.split('/');
        if (parts[parts.length - 1][0] === '%') {
          return id;
        }
        parts.pop();
        return parts.join('/');
      }
      /**
       * Finds an endpoint definition in the API.
       *
       * @param {String} endpointId Endpoint `@id` from AMF model
       * @param {?Object} api AMD model for the api. If not set, `webApi` property
       * is used.
       * @return {Object} Definition of the endpoint.
       */
      findEndpoint(endpointId, api) {
        if (api instanceof Array) {
          api = api[0];
        }
        if (!this._modelHasType(api, VOC_DOC + 'Document')) {
          return;
        }
        const encodes = api[VOC_DOC + 'encodes'];
        api = encodes.find((item) => this._modelHasType(item, 'http://schema.org/WebAPI'));
        if (!api) {
          return;
        }
        api = api[VOC_HTTP + 'endpoint'];
        if (!api) {
          return;
        }
        return api.find((item) => item['@id'] === endpointId);
      }
      /**
       * Finds a method definition on the list of operations for an endpoint.
       *
       * @param {String} id ID of the operation (method)
       * @param {Array<Object>} operations List of endpoint's operations.
       * @return {Object|undefined} Method definition.
       */
      findMethod(id, operations) {
        if (!id || !operations || !operations.length) {
          return;
        }
        return operations.find((item) => item['@id'] === id);
      }
      /**
       * Computes endpoint full URI by combining `apiBaseUri` with `path`.
       *
       * @param {String} path Endpoint's path
       * @return {String} Endpoint's full uri.
       */
      computeEndpointUri(path) {
        let result = '';
        if (this.apiBaseUri) {
          result = this.apiBaseUri;
        }
        result += path;
        return result;
      }
      /**
       * Sets up view model for parameters.
       *
       * @param {?Array} params List of parameters from the endpoint
       * definition.
       * @return {Promise}
       */
      _setupPathViewModel(params) {
        const apiParams = this.apiParameters;
        if (!params || !params.length) {
          if (apiParams) {
            this._setPathModel(Array.from(apiParams));
          }
          return Promise.resolve();
        }
        return this.$.transformer.computeViewModel(params)
        .then((data) => {
          if (apiParams) {
            data = Array.from(apiParams).concat(data);
          }
          this._setPathModel(data);
        });
      }
      /**
       * Produces view model for query parameters.
       *
       * @param {Object} method Method definition in the endpoint model.
       * @return {Promise}
       */
      _setupQueryViewModel(method) {
        const p = Promise.resolve();
        if (!method) {
          return p;
        }
        const expects = method[HYD_CORE + 'expects'];
        if (!expects) {
          return p;
        }
        const request = expects.find((item) => this._modelHasType(item, VOC_HTTP + 'Request'));
        if (!request) {
          console.warn('Expected "Request" declaration. None found.');
          return p;
        }
        const params = request[HTTP_PARAM];
        if (!params) {
          return p;
        }
        return p
        .then(() => this.$.transformer.computeViewModel(params))
        .then((data) => this._setQueryModel(data));
      }

    }

    window.customElements.define(ApiUrlDataModel.is, ApiUrlDataModel);
  })();
  </script>
</dom-module>
